/**
 * Wi-Fi Scanner - Pentesting Module
 * Cross-platform Wi-Fi network discovery for security research
 */

const { exec } = require('child_process');
const { promisify } = require('util');
const execPromise = promisify(exec);

class WiFiScanner {
  constructor() {
    this.platform = process.platform;
  }

  /**
   * Scan for nearby Wi-Fi networks
   * @returns {Promise<Array>} Array of network objects
   */
  async scan() {
    console.log(`[PENTEST] Wi-Fi scan initiated on ${this.platform}`);
    
    switch (this.platform) {
      case 'darwin':
        return await this.scanMacOS();
      case 'win32':
        return await this.scanWindows();
      case 'linux':
        return await this.scanLinux();
      default:
        throw new Error(`Platform ${this.platform} not supported`);
    }
  }

  /**
   * macOS Wi-Fi scanning using wdutil with sudo
   */
  async scanMacOS() {
    console.log('[PENTEST] Starting macOS Wi-Fi scan...');
    
    try {
      const sudo = require('sudo-prompt');
      const options = {
        name: 'Luca Network Scanner'
      };

      return new Promise((resolve) => {
        console.log('[PENTEST] Requesting sudo access for wdutil...');
        
        // Execute wdutil scan with sudo for full access
        sudo.exec('/usr/bin/wdutil scan', options, (error, stdout, stderr) => {
          if (error) {
            console.error('[PENTEST] sudo-prompt error:', error.message);
            console.log('[PENTEST] Trying without sudo as fallback...');
            
            // Try without sudo
            execPromise('/usr/bin/wdutil scan')
              .then(({ stdout }) => {
                console.log('[PENTEST] wdutil scan (no sudo) succeeded');
                const networks = this.parseWdutilOutput(stdout);
                console.log(`[PENTEST] Found ${networks.length} Wi-Fi networks`);
                resolve({ networks });
              })
              .catch((err) => {
                console.error('[PENTEST] wdutil scan (no sudo) also failed:', err.message);
                // Final fallback to current network
                this.getCurrentNetwork().then(resolve).catch(() => {
                  resolve({ networks: [], error: 'Wi-Fi scan failed. Try running Luca with sudo or grant admin access.' });
                });
              });
            return;
          }

          console.log('[PENTEST] sudo-prompt succeeded, parsing output...');
          const networks = this.parseWdutilOutput(stdout);
          console.log(`[PENTEST] Found ${networks.length} Wi-Fi networks`);
          resolve({ networks });
        });
      });
    } catch (err) {
      console.error('[PENTEST] Fatal error in scanMacOS:', err.message);
      return await this.getCurrentNetwork();
    }
  }

  /**
   * Parse wdutil scan output
   */
  parseWdutilOutput(output) {
    const networks = [];
    const lines = output.split('\n');
    let currentNetwork = null;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // SSID line
      if (line.startsWith('SSID:')) {
        // Save previous network
        if (currentNetwork && currentNetwork.ssid && currentNetwork.ssid !== '<redacted>') {
          networks.push(currentNetwork);
        }

        const ssid = line.replace('SSID:', '').trim();
        if (!ssid || ssid === '<redacted>') continue;

        currentNetwork = {
          id: `wifi_${networks.length}`,
          ssid: ssid,
          bssid: 'unknown',
          channel: 0,
          strength: 0,
          security: 'OPEN',
          label: ssid
        };
      }

      if (!currentNetwork) continue;

      // BSSID
      if (line.startsWith('BSSID:')) {
        currentNetwork.bssid = line.replace('BSSID:', '').trim();
      }

      // Channel
      if (line.startsWith('Channel:')) {
        const channelMatch = line.match(/(\d+)/);
        if (channelMatch) {
          currentNetwork.channel = parseInt(channelMatch[1]);
        }
      }

      // RSSI (signal strength)
      if (line.startsWith('RSSI:')) {
        const rssiMatch = line.match(/-?\d+/);
        if (rssiMatch) {
          const rssi = parseInt(rssiMatch[0]);
          // Convert RSSI to percentage: -30 dBm = 100%, -90 dBm = 0%
          currentNetwork.strength = Math.min(100, Math.max(0, ((rssi + 90) / 60) * 100));
          currentNetwork.strength = Math.round(currentNetwork.strength);
        }
      }

      // Security
      if (line.includes('WPA') || line.includes('WEP') || line.includes('Security')) {
        if (line.includes('WPA3')) currentNetwork.security = 'WPA3';
        else if (line.includes('WPA2')) currentNetwork.security = 'WPA2';
        else if (line.includes('WPA')) currentNetwork.security = 'WPA';
        else if (line.includes('WEP')) currentNetwork.security = 'WEP';
        else if (line.includes('Open')) currentNetwork.security = 'OPEN';
      }
    }

    // Add last network
    if (currentNetwork && currentNetwork.ssid && currentNetwork.ssid !== '<redacted>') {
      networks.push(currentNetwork);
    }

    return networks;
  }

  /**
   * Get current connected network (fallback)
   */
  async getCurrentNetwork() {
    try {
      const { stdout } = await execPromise('networksetup -getairportnetwork en0');
      const match = stdout.match(/Current Wi-Fi Network: (.+)/);
      
      if (match) {
        return {
          networks: [{
            id: 'current_network',
            ssid: match[1].trim(),
            bssid: 'unknown',
            channel: 0,
            strength: 100,
            security: 'CURRENT',
            label: match[1].trim() + ' (Current)'
          }]
        };
      }
    } catch (e) {
      console.error('[PENTEST] Could not get current network:', e.message);
    }
    
    return { networks: [], error: 'No networks found' };
  }

  /**
   * Windows Wi-Fi scanning using netsh
   */
  async scanWindows() {
    try {
      const { stdout } = await execPromise('netsh wlan show networks mode=bssid');
      const networks = this.parseNetshOutput(stdout);
      console.log(`[PENTEST] Found ${networks.length} Wi-Fi networks`);
      return { networks };
    } catch (error) {
      console.error('[PENTEST] Windows scan error:', error.message);
      return { networks: [], error: error.message };
    }
  }

  /**
   * Parse netsh output (Windows)
   */
  parseNetshOutput(output) {
    const networks = [];
    const lines = output.split('\n');
    let currentNetwork = null;

    for (const line of lines) {
      const trimmed = line.trim();

      if (trimmed.startsWith('SSID')) {
        if (currentNetwork) networks.push(currentNetwork);
        
        const ssid = trimmed.split(':')[1]?.trim();
        if (ssid) {
          currentNetwork = {
            id: `wifi_${networks.length}`,
            ssid: ssid,
            bssid: 'unknown',
            channel: 0,
            strength: 0,
            security: 'OPEN',
            label: ssid
          };
        }
      }

      if (!currentNetwork) continue;

      if (trimmed.startsWith('Signal')) {
        const match = trimmed.match(/(\d+)%/);
        if (match) {
          currentNetwork.strength = parseInt(match[1]);
        }
      }

      if (trimmed.includes('Authentication')) {
        if (trimmed.includes('WPA2')) currentNetwork.security = 'WPA2';
        else if (trimmed.includes('WPA')) currentNetwork.security = 'WPA';
        else if (trimmed.includes('WEP')) currentNetwork.security = 'WEP';
        else if (trimmed.includes('Open')) currentNetwork.security = 'OPEN';
      }
    }

    if (currentNetwork) networks.push(currentNetwork);
    return networks;
  }

  /**
   * Linux Wi-Fi scanning using iw/iwlist
   */
  async scanLinux() {
    try {
      // Try iw first (modern)
      const { stdout } = await execPromise('sudo iw dev wlan0 scan');
      const networks = this.parseIwOutput(stdout);
      console.log(`[PENTEST] Found ${networks.length} Wi-Fi networks`);
      return { networks };
    } catch (e) {
      // Fallback to iwlist
      try {
        const { stdout } = await execPromise('sudo iwlist wlan0 scan');
        const networks = this.parseIwlistOutput(stdout);
        console.log(`[PENTEST] Found ${networks.length} Wi-Fi networks`);
        return { networks };
      } catch (error) {
        console.error('[PENTEST] Linux scan error:', error.message);
        return { networks: [], error: error.message };
      }
    }
  }

  /**
   * Parse iw output (Linux)
   */
  parseIwOutput(output) {
    const networks = [];
    const lines = output.split('\n');
    let currentNetwork = null;

    for (const line of lines) {
      const trimmed = line.trim();

      if (trimmed.startsWith('BSS')) {
        if (currentNetwork) networks.push(currentNetwork);
        
        const bssid = trimmed.split(' ')[1];
        currentNetwork = {
          id: `wifi_${networks.length}`,
          ssid: 'unknown',
          bssid: bssid,
          channel: 0,
          strength: 0,
          security: 'OPEN',
          label: 'unknown'
        };
      }

      if (!currentNetwork) continue;

      if (trimmed.startsWith('SSID:')) {
        const ssid = trimmed.replace('SSID:', '').trim();
        if (ssid) {
          currentNetwork.ssid = ssid;
          currentNetwork.label = ssid;
        }
      }

      if (trimmed.startsWith('signal:')) {
        const match = trimmed.match(/-?\d+/);
        if (match) {
          const dbm = parseInt(match[0]);
          currentNetwork.strength = Math.min(100, Math.max(0, ((dbm + 90) / 60) * 100));
          currentNetwork.strength = Math.round(currentNetwork.strength);
        }
      }

      if (trimmed.includes('WPA') || trimmed.includes('WEP')) {
        if (trimmed.includes('WPA2')) currentNetwork.security = 'WPA2';
        else if (trimmed.includes('WPA')) currentNetwork.security = 'WPA';
        else if (trimmed.includes('WEP')) currentNetwork.security = 'WEP';
      }
    }

    if (currentNetwork) networks.push(currentNetwork);
    return networks.filter(n => n.ssid !== 'unknown');
  }

  /**
   * Parse iwlist output (Linux fallback)
   */
  parseIwlistOutput(output) {
    // Similar to iw but different format
    // Implementation similar to parseIwOutput
    return [];
  }
}

module.exports = WiFiScanner;
